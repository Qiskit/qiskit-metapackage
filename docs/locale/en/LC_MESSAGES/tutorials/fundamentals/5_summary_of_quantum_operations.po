# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-22 00:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:9
msgid "Summary of Quantum Operations"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:16
msgid ""
"In this section we will go into the different operations that are "
"available in Qiskit Terra. These are: - Single-qubit quantum gates - "
"Multi-qubit quantum gates - Measurements - Reset - Conditionals - State "
"initialization"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:18
msgid ""
"We will also show you how to use the three different simulators: - "
"unitary\\_simulator - qasm\\_simulator - statevector\\_simulator"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:51
msgid "Single Qubit Quantum states"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:53
msgid "A single qubit quantum state can be written as"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:55
msgid ""
"\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta "
"\\left|1\\right\\rangle"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:57
msgid ""
"where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a "
"measurement the probability of the bit being in "
":math:`\\left|0\\right\\rangle` is :math:`|\\alpha|^2` and "
":math:`\\left|1\\right\\rangle` is :math:`|\\beta|^2`. As a vector this "
"is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:59
msgid ""
"\\left|\\psi\\right\\rangle = \\begin{pmatrix} \\alpha \\\\ \\beta "
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:68
msgid ""
"Note, due to the conservation of probability :math:`|\\alpha|^2+ "
"|\\beta|^2 = 1` and since global phase is undetectable "
":math:`\\left|\\psi\\right\\rangle := e^{i\\delta} "
"\\left|\\psi\\right\\rangle` we only require two real numbers to describe"
" a single qubit quantum state."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:70
msgid "A convenient representation is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:72
msgid ""
"\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + "
"\\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:74
msgid ""
"where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq "
"\\pi`. From this, it is clear that there is a one-to-one correspondence "
"between qubit states (:math:`\\mathbb{C}^2`) and the points on the "
"surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the "
"Bloch sphere representation of a qubit state."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:76
msgid ""
"Quantum gates/operations are usually represented as matrices. A gate "
"which acts on a qubit is represented by a :math:`2\\times 2` unitary "
"matrix :math:`U`. The action of the quantum gate is found by multiplying "
"the matrix representing the gate with the vector which represents the "
"quantum state."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:78
msgid "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:80
msgid ""
"A general unitary must be able to take the "
":math:`\\left|0\\right\\rangle` to the above state. That is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:82
msgid ""
"U = \\begin{pmatrix} \\cos(\\theta/2) & a \\\\ e^{i\\phi}\\sin(\\theta/2)"
" & b \\end{pmatrix}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:90
msgid ""
"where :math:`a` and :math:`b` are complex numbers constrained such that "
":math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and "
":math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such "
":math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and "
":math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where "
":math:`0\\leq \\lambda<2\\pi` giving"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:92
msgid ""
"U = \\begin{pmatrix} \\cos(\\theta/2) & -e^{i\\lambda}\\sin(\\theta/2) "
"\\\\ e^{i\\phi}\\sin(\\theta/2) & e^{i\\lambda+i\\phi}\\cos(\\theta/2) "
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:100
msgid "This is the most general form of a single qubit unitary."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:108
msgid "Single-Qubit Gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:110
msgid ""
"The single-qubit gates available are: - u gates - Identity gate - Pauli "
"gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:112
msgid ""
"We have provided a backend: ``unitary_simulator`` to allow you to "
"calculate the unitary matrices."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:128
msgid "u gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:130
msgid ""
"In Qiskit we give you access to the general unitary using the :math:`u3` "
"gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:132
msgid "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:220
msgid ""
"The :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` gate has the"
" matrix form"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:222
msgid ""
"u2(\\phi, \\lambda) = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & "
"-e^{i\\lambda} \\\\ e^{i\\phi} & e^{i(\\phi + \\lambda)} \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:231
msgid "This is a useful gate as it allows us to create superpositions."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:316
msgid "The :math:`u1(\\lambda)= u3(0, 0, \\lambda)` gate has the matrix form"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:318
msgid ""
"u1(\\lambda) = \\begin{pmatrix} 1 & 0 \\\\ 0 & e^{i \\lambda} "
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:327
msgid "which is useful as it allows us to apply a quantum phase."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:413
msgid "Identity gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:415
msgid "The identity gate is :math:`Id = u0(1)`."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:523
msgid "Pauli gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:526
msgid ":math:`X`: bit-flip gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:528
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:530
msgid "X   = \\begin{pmatrix} 0 & 1\\\\ 1 & 0 \\end{pmatrix}= u3(\\pi,0,\\pi)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:623
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:625
msgid "The :math:`Y` gate is defined as:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:627
msgid ""
"Y  = \\begin{pmatrix} 0 & -i\\\\ i & 0 "
"\\end{pmatrix}=u3(\\pi,\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:720
msgid ":math:`Z`: phase-flip gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:722
msgid "The phase-flip gate :math:`Z` is defined as:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:724
msgid "Z = \\begin{pmatrix} 1 & 0\\\\ 0 & -1 \\end{pmatrix}=u1(\\pi)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:817
msgid "Clifford gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:820
msgid "Hadamard gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:822
msgid ""
"H = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1\\\\ 1 & -1 "
"\\end{pmatrix}= u2(0,\\pi)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:916
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:918
msgid "S = \\begin{pmatrix} 1 & 0\\\\ 0 & i \\end{pmatrix}= u1(\\pi/2)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1011
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1013
msgid ""
"S^{\\dagger} = \\begin{pmatrix} 1 & 0\\\\ 0 & -i \\end{pmatrix}= "
"u1(-\\pi/2)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1106
msgid ":math:`C3` gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1109
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1111
msgid "T = \\begin{pmatrix} 1 & 0\\\\ 0 & e^{i \\pi/4} \\end{pmatrix}= u1(\\pi/4)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1204
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1206
msgid ""
"T^{\\dagger} = \\begin{pmatrix} 1 & 0\\\\ 0 & e^{-i \\pi/4} "
"\\end{pmatrix}= u1(-pi/4)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1299
msgid "Standard Rotations"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1301
msgid ""
"The standard rotation gates are those that define rotations around the "
"Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1303
msgid ""
"R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i "
"\\sin(\\theta/2)P"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1306
msgid "Rotation around X-axis"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1308
msgid ""
"R_x(\\theta) = \\begin{pmatrix} \\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\"
" -i\\sin(\\theta/2) & \\cos(\\theta/2) \\end{pmatrix} = u3(\\theta, "
"-\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1401
msgid "Rotation around Y-axis"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1403
msgid ""
"R_y(\\theta) = \\begin{pmatrix} \\cos(\\theta/2) & - \\sin(\\theta/2)\\\\"
" \\sin(\\theta/2) & \\cos(\\theta/2). \\end{pmatrix} =u3(\\theta,0,0)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1496
msgid "Rotation around Z-axis"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1498
msgid ""
"R_z(\\phi) = \\begin{pmatrix} e^{-i \\phi/2} & 0 \\\\ 0 & e^{i \\phi/2} "
"\\end{pmatrix}\\equiv u1(\\phi)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1507
msgid ""
"Note that here we have used an equivalent as it is different to u1 by a "
"global phase :math:`e^{-i \\phi/2}`."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1592
msgid "Note this is different due only to a global phase."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1600
msgid "Multi-Qubit Gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1603
msgid "Mathematical Preliminaries"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1605
msgid ""
"The space of a quantum computer grows exponentially with the number of "
"qubits. For :math:`n` qubits the complex vector space has dimension "
":math:`d=2^n`. To describe states of a multi-qubit system, the tensor "
"product is used to \"glue together\" operators and basis vectors."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1607
msgid ""
"Let's start by considering a 2-qubit system. Given two operators "
":math:`A` and :math:`B` that each act on one qubit, the joint operator "
":math:`A \\otimes B` acting on two qubits is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1609
msgid ""
"\\begin{equation}     A\\otimes B =     \\begin{pmatrix}         A_{00} "
"\\begin{pmatrix}             B_{00} & B_{01} \\\\             B_{10} & "
"B_{11}         \\end{pmatrix} & A_{01}  \\begin{pmatrix}                 "
"B_{00} & B_{01} \\\\                 B_{10} & B_{11}             "
"\\end{pmatrix} \\\\         A_{10}  \\begin{pmatrix}                     "
"B_{00} & B_{01} \\\\                     B_{10} & B_{11}                 "
"\\end{pmatrix} & A_{11}  \\begin{pmatrix}                             "
"B_{00} & B_{01} \\\\                             B_{10} & B_{11}"
"                         \\end{pmatrix}     \\end{pmatrix}, "
"\\end{equation}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1631
msgid ""
"where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of "
":math:`A` and :math:`B`, respectively."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1633
msgid ""
"Analogously, the basis vectors for the 2-qubit system are formed using "
"the tensor product of basis vectors for a single qubit:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1635
msgid ""
"\\begin{equation}\\begin{split}     \\left|{00}\\right\\rangle &= "
"\\begin{pmatrix}         1 \\begin{pmatrix}             1  \\\\"
"             0         \\end{pmatrix} \\\\         0 \\begin{pmatrix}"
"             1  \\\\             0         \\end{pmatrix}     "
"\\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 "
"\\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}     1 "
"\\begin{pmatrix}     0 \\\\     1     \\end{pmatrix} \\\\     0 "
"\\begin{pmatrix}     0  \\\\     1     \\end{pmatrix}     \\end{pmatrix} "
"= \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split} "
"\\end{equation}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1659
msgid ""
"\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = "
"\\begin{pmatrix}     0\\begin{pmatrix}     1  \\\\     0     "
"\\end{pmatrix} \\\\     1\\begin{pmatrix}     1 \\\\     0     "
"\\end{pmatrix}     \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\"
" 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}     "
"0 \\begin{pmatrix}     0  \\\\     1     \\end{pmatrix} \\\\     "
"1\\begin{pmatrix}     0  \\\\     1     \\end{pmatrix}     \\end{pmatrix}"
" = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split} "
"\\end{equation}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1682
msgid ""
"Note we've introduced a shorthand for the tensor product of basis "
"vectors, wherein :math:`\\left|0\\right\\rangle \\otimes "
"\\left|0\\right\\rangle` is written as :math:`\\left|00\\right\\rangle`. "
"The state of an :math:`n`-qubit system can be described using the "
":math:`n`-fold tensor product of single-qubit basis vectors. Notice that "
"the basis vectors for a 2-qubit system are 4-dimensional; in general, the"
" basis vectors of an :math:`n`-qubit sytsem are "
":math:`2^{n}`-dimensional, as noted earlier."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1685
msgid "Basis vector ordering in Qiskit"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1687
msgid ""
"Within the physics community, the qubits of a multi-qubit systems are "
"typically ordered with the first qubit on the left-most side of the "
"tensor product and the last qubit on the right-most side. For instance, "
"if the first qubit is in state :math:`\\left|0\\right\\rangle` and second"
" is in state :math:`\\left|1\\right\\rangle`, their joint state would be "
":math:`\\left|01\\right\\rangle`. Qiskit uses a slightly different "
"ordering of the qubits, in which the qubits are represented from the most"
" significant bit (MSB) on the left to the least significant bit (LSB) on "
"the right (big-endian). This is similar to bitstring representation on "
"classical computers, and enables easy conversion from bitstrings to "
"integers after measurements are performed. For the example just given, "
"the joint state would be represented as :math:`\\left|10\\right\\rangle`."
" Importantly, *this change in the representation of multi-qubit states "
"affects the way multi-qubit gates are represented in Qiskit*, as "
"discussed below."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1690
msgid ""
"The representation used in Qiskit enumerates the basis vectors in "
"increasing order of the integers they represent. For instance, the basis "
"vectors for a 2-qubit system would be ordered as "
":math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, "
":math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle`. "
"Thinking of the basis vectors as bit strings, they encode the integers "
"0,1,2 and 3, respectively."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1693
msgid "Controlled operations on qubits"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1695
msgid ""
"A common multi-qubit gate involves the application of a gate to one "
"qubit, conditioned on the state of another qubit. For instance, we might "
"want to flip the state of the second qubit when the first qubit is in "
":math:`\\left|0\\right\\rangle`. Such gates are known as *controlled "
"gates*. The standard multi-qubit gates consist of two-qubit gates and "
"three-qubit gates. The two-qubit gates are: - controlled Pauli gates - "
"controlled Hadamard gate - controlled rotation gates - controlled phase "
"gate - controlled u3 gate - swap gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1698
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1706
msgid "Two-qubit gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1708
msgid ""
"Most of the two-qubit gates are of the controlled type (the SWAP gate "
"being the exception). In general, a controlled two-qubit gate "
":math:`C_{U}` acts to apply the single-qubit unitary :math:`U` to the "
"second qubit when the state of the first qubit is in "
":math:`\\left|1\\right\\rangle`. Suppose :math:`U` has a matrix "
"representation"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1710
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1712
msgid ""
"We can work out the action of :math:`C_{U}` as follows. Recall that the "
"basis vectors for a two-qubit system are ordered as "
":math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, "
"\\left|10\\right\\rangle, \\left|11\\right\\rangle`. Suppose the "
"**control qubit** is **qubit 0** (which, according to Qiskit's "
"convention, is one the *right-hand* side of the tensor product). If the "
"control qubit is in :math:`\\left|1\\right\\rangle`, :math:`U` should be "
"applied to the **target** (qubit 1, on the *left-hand* side of the tensor"
" product). Therefore, under the action of :math:`C_{U}`, the basis "
"vectors are transformed according to"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1715
msgid ""
"\\begin{align*} C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\ \\end{align*}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1724
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1726
msgid ""
"\\begin{equation}     C_U = \\begin{pmatrix}     1 & 0 & 0 & 0 \\\\     0"
" & u_{00} & 0 & u_{01} \\\\     0 & 0 & 1 & 0 \\\\     0 & u_{10} &0 & "
"u_{11}         \\end{pmatrix}. \\end{equation}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1737
msgid "To work out these matrix elements, let"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1739
msgid ""
"C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j "
"\\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k "
"\\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l "
"\\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| k "
"\\right\\rangle}\\right),"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1741
msgid ""
"compute the action of :math:`C_{U}` (given above), and compute the inner "
"products."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1743
msgid ""
"As shown in the examples below, this operation is implemented in Qiskit "
"as ``cU(q[0],q[1])``."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1745
msgid ""
"If **qubit 1 is the control and qubit 0 is the target**, then the basis "
"vectors are transformed according to"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1747
msgid ""
"\\begin{align*} C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\ \\end{align*},"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1756
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1758
msgid ""
"\\begin{equation}     C_U = \\begin{pmatrix}     1 & 0 & 0  & 0 \\\\     "
"0 & 1 & 0 & 0 \\\\     0 & 0 & u_{00} & u_{01} \\\\     0 & 0 & u_{10} & "
"u_{11}         \\end{pmatrix}. \\end{equation}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1783
msgid "Controlled Pauli Gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1786
msgid "Controlled-X (or, controlled-NOT) gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1788
msgid ""
"The controlled-not gate flips the ``target`` qubit when the control qubit"
" is in the state :math:`\\left|1\\right\\rangle`. If we take the MSB as "
"the control qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look "
"like"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1790
msgid ""
"C_X = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & "
"1\\\\ 0 & 0 & 1 & 0 \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1801
msgid ""
"However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), "
"this gate is equivalent to the following matrix:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1803
msgid ""
"C_X = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 1\\\\ 0 & 0 & 1 & "
"0\\\\ 0 & 1 & 0 & 0 \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1908
msgid "Controlled :math:`Y` gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1910
msgid ""
"Apply the :math:`Y` gate to the target qubit if the control qubit is the "
"MSB"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1912
msgid ""
"C_Y = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & "
"-i\\\\ 0 & 0 & i & 0 \\end{pmatrix},"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1923
msgid "or when the LSB is the control"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:1925
msgid ""
"C_Y = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & -i\\\\ 0 & 0 & 1 & "
"0\\\\ 0 & i & 0 & 0 \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2030
msgid "Controlled :math:`Z` (or, controlled Phase) gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2032
msgid ""
"Similarly, the controlled Z gate flips the phase of the target qubit if "
"the control qubit is :math:`\\left|1\\right\\rangle`. The matrix looks "
"the same regardless of whether the MSB or LSB is the control qubit:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2034
msgid ""
"C_Z = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & "
"0\\\\ 0 & 0 & 0 & -1 \\end{pmatrix}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2139
msgid "Controlled Hadamard gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2141
msgid ""
"Apply :math:`H` gate to the target qubit if the control qubit is "
":math:`\\left|1\\right\\rangle`. Below is the case where the control is "
"the LSB qubit."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2143
msgid ""
"C_H = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & \\frac{1}{\\sqrt{2}} & 0 & "
"\\frac{1}{\\sqrt{2}}\\\\ 0 & 0 & 1 & 0\\\\ 0 & \\frac{1}{\\sqrt{2}}  & 0&"
" -\\frac{1}{\\sqrt{2}} \\end{pmatrix}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2248
msgid "Controlled rotation gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2251
msgid "Controlled rotation around Z-axis"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2253
msgid ""
"Perform rotation around Z-axis on the target qubit if the control qubit "
"(here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2255
msgid ""
"C_{Rz}(\\lambda) = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & "
"e^{-i\\lambda/2} & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & "
"e^{i\\lambda/2} \\end{pmatrix}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2360
msgid "Controlled phase rotation"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2362
msgid ""
"Perform a phase rotation if both qubits are in the "
":math:`\\left|11\\right\\rangle` state. The matrix looks the same "
"regardless of whether the MSB or LSB is the control qubit."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2364
msgid ""
"C_{u1}(\\lambda) = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0"
" & 0 & 1 & 0\\\\ 0 & 0 & 0 & e^{i\\lambda} \\end{pmatrix}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2469
msgid "Controlled :math:`u3` rotation"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2471
msgid ""
"Perform controlled-\\ :math:`u3` rotation on the target qubit if the "
"control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2473
msgid ""
"C_{u3}(\\theta, \\phi, \\lambda) \\equiv \\begin{pmatrix} 1 & 0 & 0 & "
"0\\\\ 0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & "
"-e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\ 0 & 0 & 1 & 0\\\\ 0 & "
"e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & "
"e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2) \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2578
msgid "SWAP gate"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2580
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2582
msgid ""
"\\left|00\\right\\rangle \\rightarrow "
"\\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow "
"\\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow "
"\\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow "
"\\left|11\\right\\rangle,"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2584
msgid "which gives a matrix representation of the form"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2586
msgid ""
"\\mathrm{SWAP} = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 &"
" 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2691
msgid "Three-qubit gates"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2693
msgid ""
"There are two commonly-used three-qubit gates. For three qubits, the "
"basis vectors are ordered as"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2695
msgid ""
"\\left|000\\right\\rangle, \\left|001\\right\\rangle, "
"\\left|010\\right\\rangle, \\left|011\\right\\rangle, "
"\\left|100\\right\\rangle, \\left|101\\right\\rangle, "
"\\left|110\\right\\rangle, \\left|111\\right\\rangle,"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2697
msgid ""
"which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. "
"Again, Qiskit uses a representation in which the first qubit is on the "
"right-most side of the tensor product and the third qubit is on the left-"
"most side:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2699
msgid ""
"\\left|abc\\right\\rangle : \\underset{\\text{qubit "
"2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit "
"1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit "
"0}}{\\left|c\\right\\rangle}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2707
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2709
msgid ""
"The `Toffoli gate "
"<https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__"
" flips the third qubit if the first two qubits (LSB) are both "
":math:`\\left|1\\right\\rangle`:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2711
msgid ""
"\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle "
"\\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2713
msgid "In matrix form, the Toffoli gate is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2715
msgid ""
"C_{CX} = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0"
" & 0 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 "
"& 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 1 &"
" 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & "
"0 \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2846
msgid "Controlled swap gate (Fredkin Gate)"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2848
msgid ""
"The `Fredkin gate "
"<https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__,"
" or the *controlled swap gate*, exchanges the second and third qubits if "
"the first qubit (LSB) is :math:`\\left|1\\right\\rangle`:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2850
msgid ""
"\\left|abc\\right\\rangle \\rightarrow \\begin{cases} "
"\\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr "
"\\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2852
msgid "In matrix form, the Fredkin gate is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2854
msgid ""
"C_{\\mathrm{SWAP}} = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\ 0"
" & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 "
"& 0 & 0 & 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 &"
" 1 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 0 & "
"0 & 0 & 0 & 1 \\end{pmatrix}."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2977
msgid "Non-unitary operations"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2979
msgid ""
"Now that we have gone through all the unitary operations in quantum "
"circuits, we also have access to non-unitary operations. These include "
"measurements, reset of qubits, and classical conditional operations."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2996
msgid "Measurements"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:2998
msgid ""
"We don't have access to all the information when we make a measurement in"
" a quantum computer. The quantum state is projected onto the standard "
"basis. Below are two examples showing a circuit that is prepared in a "
"basis state and the quantum computer prepared in a superposition state."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3088
msgid ""
"The simulator predicts that 100 percent of the time the classical "
"register returns 0."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3178
msgid ""
"The simulator predicts that 50 percent of the time the classical register"
" returns 0 or 1."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3186
msgid "Reset"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3188
msgid ""
"It is also possible to ``reset`` qubits to the "
":math:`\\left|0\\right\\rangle` state in the middle of computation. Note "
"that ``reset`` is not a Gate operation, since it is irreversible."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3362
msgid ""
"Here we see that for both of these circuits the simulator always predicts"
" that the output is 100 percent in the 0 state."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3370
msgid "Conditional operations"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3372
msgid ""
"It is also possible to do operations conditioned on the state of the "
"classical register"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3437
msgid ""
"Here the classical bit always takes the value 0 so the qubit state is "
"always flipped."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3560
msgid ""
"Here the classical bit by the first measurement is random but the "
"conditional operation results in the qubit being deterministically put "
"into :math:`\\left|1\\right\\rangle`."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3568
msgid "Arbitrary initialization"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3570
msgid ""
"What if we want to initialize a qubit register to an arbitrary state? An "
"arbitrary state for :math:`n` qubits may be specified by a vector of "
":math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals "
"1. For example, the following three-qubit state can be prepared:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3572
msgid ""
"\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + "
"\\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + "
"\\frac{1+i}{4}\\left|010\\right\\rangle + "
"\\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + "
"\\frac{1}{4}\\left|110\\right\\rangle"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3649
msgid ""
"`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ "
"is useful to check whether two states are the same or not. For quantum "
"(pure) states :math:`\\left|\\psi_1\\right\\rangle` and "
":math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3651
msgid ""
"F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right)"
" = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3656
msgid "The fidelity is equal to :math:`1` if and only if two states are equal."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3693
msgid ""
"How does the desired state get generated behind the scenes? There are "
"multiple methods for doing this. Qiskit uses a `method proposed by Shende"
" et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to "
"assume the quantum register to have started from our desired state, and "
"construct a circuit that takes it to the "
":math:`\\left|00..0\\right\\rangle` state. The initialization circuit is "
"then the reverse of such circuit."
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3695
msgid ""
"To take an arbitrary quantum state to the zero state in the computational"
" basis, we perform an iterative procedure that disentangles qubits from "
"the register one-by-one. We know that any arbitrary single-qubit state "
":math:`\\left|\\rho\\right\\rangle` can be taken to the "
":math:`\\left|0\\right\\rangle` state using a :math:`\\phi`-degree "
"rotation about the Z axis followed by a :math:`\\theta`-degree rotation "
"about the Y axis:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3697
msgid ""
"R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = "
"re^{it}\\left|0\\right\\rangle"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3699
msgid ""
"Since now we are dealing with :math:`n` qubits instead of just 1, we must"
" factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3701
msgid ""
"\\begin{align*}  \\left|\\psi\\right\\rangle =& "
"\\alpha_{0_0}\\left|00..00\\right\\rangle + "
"\\alpha_{0_1}\\left|00..01\\right\\rangle + "
"\\alpha_{1_0}\\left|00..10\\right\\rangle + "
"\\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ "
"\\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + "
"\\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\ =& "
"\\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + "
"\\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle "
"(\\alpha_{1_0}\\left|0\\right\\rangle + "
"\\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ "
"\\left|11..1\\right\\rangle "
"(\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + "
"\\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\ =& "
"\\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + "
"\\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + "
"\\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle "
"\\end{align*}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3709
msgid ""
"Now each of the single-qubit states :math:`\\left|\\rho_0\\right\\rangle,"
" ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` can be taken to "
":math:`\\left|0\\right\\rangle` by finding appropriate :math:`\\phi` and "
":math:`\\theta` angles per the equation above. Doing this simultaneously "
"on all states amounts to the following unitary, which disentangles the "
"LSB:"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3711
msgid ""
"U = \\begin{pmatrix} R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\ & "
"R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\ & . & & &\\\\ & & . & &\\\\ & "
"& & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1}) \\end{pmatrix}"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3721
msgid "Hence,"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3723
msgid ""
"U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ "
"r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} "
"\\end{pmatrix}\\otimes\\left|0\\right\\rangle"
msgstr ""

#: ../../tutorials/fundamentals/5_summary_of_quantum_operations.ipynb:3725
msgid ""
"U can be implemented as a \"quantum multiplexor\" gate, since it is a "
"block diagonal matrix. In the quantum multiplexor formalism, a block "
"diagonal matrix of size :math:`2^n \\times 2^n`, and consisting of "
":math:`2^s` blocks, is equivalent to a multiplexor with :math:`s` select "
"qubits and :math:`n-s` data qubits. Depending on the state of the select "
"qubits, the corresponding blocks are applied to the data qubits. A "
"multiplexor of this kind can be implemented after recursive decomposition"
" to primitive gates of cx, rz and ry."
msgstr ""

