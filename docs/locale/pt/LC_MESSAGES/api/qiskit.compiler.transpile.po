msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-13 16:11+0000\n"
"PO-Revision-Date: 2019-09-16 15:19\n"
"Last-Translator: lzdanski\n"
"Language-Team: Portuguese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: crowdin.com\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Language: pt-PT\n"
"X-Crowdin-File: /poBranch/docs/locale/en/LC_MESSAGES/api/qiskit.compiler.transpile.po\n"
"Language: pt_PT\n"

#: ../../api/qiskit.compiler.transpile.rst:2
msgid "transpile"
msgstr ""

#: of qiskit.compiler.transpile:1
msgid "Transpile one or more circuits, according to some desired transpilation targets."
msgstr ""

#: of qiskit.compiler.transpile:3
msgid "All arguments may be given as either singleton or list. In case of list, the length must be equal to the number of circuits being transpiled."
msgstr ""

#: of qiskit.compiler.transpile:6
msgid "Transpilation is done in parallel using multiprocessing."
msgstr ""

#: of qiskit.compiler.transpile
msgid "Parameters"
msgstr ""

#: of qiskit.compiler.transpile:8
msgid "Circuit(s) to transpile"
msgstr ""

#: of qiskit.compiler.transpile:10
msgid "If set, transpiler options are automatically grabbed from backend.configuration() and backend.properties(). If any other option is explicitly set (e.g. coupling_map), it will override the backend's.  Note: the backend arg is purely for convenience. The resulting circuit may be run on any backend as long as it is compatible."
msgstr ""

#: of qiskit.compiler.transpile:10
msgid "If set, transpiler options are automatically grabbed from backend.configuration() and backend.properties(). If any other option is explicitly set (e.g. coupling_map), it will override the backend's."
msgstr ""

#: of qiskit.compiler.transpile:15
msgid "Note: the backend arg is purely for convenience. The resulting circuit may be run on any backend as long as it is compatible."
msgstr ""

#: of qiskit.compiler.transpile:18
msgid "List of basis gate names to unroll to. e.g::      ['u1', 'u2', 'u3', 'cx']  If None, do not unroll."
msgstr ""

#: of qiskit.compiler.transpile:18
msgid "List of basis gate names to unroll to. e.g::"
msgstr ""

#: of qiskit.compiler.transpile:23
msgid "If None, do not unroll."
msgstr ""

#: of qiskit.compiler.transpile:25
msgid "Coupling map (perhaps custom) to target in mapping. Multiple formats are supported:  1. CouplingMap instance 2. list     Must be given as an adjacency matrix, where each entry     specifies all two-qubit interactions supported by backend     e.g::          [[0, 1], [0, 3], [1, 2], [1, 5], [2, 5], [4, 1], [5, 3]]"
msgstr ""

#: of qiskit.compiler.transpile:25
msgid "Coupling map (perhaps custom) to target in mapping. Multiple formats are supported:"
msgstr ""

#: of qiskit.compiler.transpile:28
msgid "CouplingMap instance"
msgstr ""

#: of qiskit.compiler.transpile:33 qiskit.compiler.transpile:69
msgid "list"
msgstr ""

#: of qiskit.compiler.transpile:30
msgid "Must be given as an adjacency matrix, where each entry specifies all two-qubit interactions supported by backend e.g::"
msgstr ""

#: of qiskit.compiler.transpile:36
msgid "properties returned by a backend, including information on gate errors, readout errors, qubit coherence times, etc. For a backend that provides this information, it can be obtained with: ``backend.properties()``"
msgstr ""

#: of qiskit.compiler.transpile:41
msgid "Initial position of virtual qubits on physical qubits. If this layout makes the circuit compatible with the coupling_map constraints, it will be used. The final layout is not guaranteed to be the same, as the transpiler may permute qubits through swaps or other means.  Multiple formats are supported:  1. Layout instance 2. dict     * virtual to physical::          {qr[0]: 0,          qr[1]: 3,          qr[2]: 5}      * physical to virtual::          {0: qr[0],          3: qr[1],          5: qr[2]}  3. list     * virtual to physical::          [0, 3, 5]  # virtual qubits are ordered (in addition to named)      * physical to virtual::          [qr[0], None, None, qr[1], None, qr[2]]"
msgstr ""

#: of qiskit.compiler.transpile:41
msgid "Initial position of virtual qubits on physical qubits. If this layout makes the circuit compatible with the coupling_map constraints, it will be used. The final layout is not guaranteed to be the same, as the transpiler may permute qubits through swaps or other means."
msgstr ""

#: of qiskit.compiler.transpile:47
msgid "Multiple formats are supported:"
msgstr ""

#: of qiskit.compiler.transpile:49
msgid "Layout instance"
msgstr ""

#: of qiskit.compiler.transpile:61
msgid "dict"
msgstr ""

#: of qiskit.compiler.transpile:51 qiskit.compiler.transpile:64
msgid "virtual to physical::"
msgstr ""

#: of qiskit.compiler.transpile:57 qiskit.compiler.transpile:68
msgid "physical to virtual::"
msgstr ""

#: of qiskit.compiler.transpile:72
msgid "sets random seed for the stochastic parts of the transpiler"
msgstr ""

#: of qiskit.compiler.transpile:74
msgid "How much optimization to perform on the circuits. Higher levels generate more optimized circuits, at the expense of longer transpilation time.      * 0: no optimization     * 1: light optimization     * 2: heavy optimization     * 3: even heavier optimization  If None, level 1 will be chosen as default."
msgstr ""

#: of qiskit.compiler.transpile:74
msgid "How much optimization to perform on the circuits. Higher levels generate more optimized circuits, at the expense of longer transpilation time."
msgstr ""

#: of qiskit.compiler.transpile:78
msgid "0: no optimization"
msgstr ""

#: of qiskit.compiler.transpile:79
msgid "1: light optimization"
msgstr ""

#: of qiskit.compiler.transpile:80
msgid "2: heavy optimization"
msgstr ""

#: of qiskit.compiler.transpile:81
msgid "3: even heavier optimization"
msgstr ""

#: of qiskit.compiler.transpile:83
msgid "If None, level 1 will be chosen as default."
msgstr ""

#: of qiskit.compiler.transpile:85
msgid "The pass manager to use for a custom pipeline of transpiler passes. If this arg is present, all other args will be ignored and the pass manager will be used directly (Qiskit will not attempt to auto-select a pass manager based on transpile options)."
msgstr ""

#: of qiskit.compiler.transpile:90
msgid "A callback function that will be called after each pass execution. The function will be called with 5 keyword :param pass\\_: the pass being run :type pass\\_: Pass :param dag: the dag output of the pass :type dag: DAGCircuit :param time: the time to execute the pass :type time: float :param property_set: the property set :type property_set: PropertySet :param count: the index for the pass execution :type count: int  The exact arguments pass expose the internals of the pass manager and are subject to change as the pass manager internals change. If you intend to reuse a callback function over multiple releases be sure to check that the arguments being passed are the same.  To use the callback feature you define a function that will take in kwargs dict and access the variables. For example::      def callback_func(**kwargs):         pass_ = kwargs['pass_']         dag = kwargs['dag']         time = kwargs['time']         property_set = kwargs['property_set']         count = kwargs['count']         ...      transpile(circ, callback=callback_func)"
msgstr ""

#: of qiskit.compiler.transpile:90
msgid "A callback function that will be called after each pass execution. The function will be called with 5 keyword :param pass\\_: the pass being run :type pass\\_: Pass :param dag: the dag output of the pass :type dag: DAGCircuit :param time: the time to execute the pass :type time: float :param property_set: the property set :type property_set: PropertySet :param count: the index for the pass execution :type count: int"
msgstr ""

#: of qiskit.compiler.transpile:103
msgid "The exact arguments pass expose the internals of the pass manager and are subject to change as the pass manager internals change. If you intend to reuse a callback function over multiple releases be sure to check that the arguments being passed are the same."
msgstr ""

#: of qiskit.compiler.transpile:108
msgid "To use the callback feature you define a function that will take in kwargs dict and access the variables. For example::"
msgstr ""

#: of qiskit.compiler.transpile:121
msgid "A list with strings to identify the output circuits. The length of `list[str]` should be exactly the length of `circuits` parameter."
msgstr ""

#: of qiskit.compiler.transpile
msgid "Returns"
msgstr ""

#: of qiskit.compiler.transpile:125
msgid "transpiled circuit(s)."
msgstr ""

#: of qiskit.compiler.transpile
msgid "Return type"
msgstr ""

#: of qiskit.compiler.transpile
msgid "Raises"
msgstr ""

#: of qiskit.compiler.transpile:128
msgid "in case of bad inputs to transpiler or errors in passes"
msgstr ""

